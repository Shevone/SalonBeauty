Опишу что есть

- Иерархия классов
1. Базовый абстракный класс - услуга
2. Его наследники - Маникюр, Спа процедура, Работа св волосами так называемая
В класс наследники добавил различные детали
- требуется ли мойка волос
- цвет маникюра
- Время на спа процендуру

Так же добавил пример инкапсуляции(это надо в первой лабе, но вдргу споросит)
- в файле SpaProcedure то как мы устанавливаем время - на строке 5 у нас есть поле, которое хранит значене, однако обращаемся
мы к нему через свойство на строке 9. Там в set мы скрываем проверку правильности передданного значения

В абстракный класс добавил абстракный меотд DisplayInfo - метод который должен быть переопределе в каждом классе - наследнике.
Он переводин объект услуг в подробную информацию в строковом виде. В развных классах свое отображение. Вызов этого метода считается полиморфным (это нужно было в первой лабе, но вдруг спросит) - 
в классе SalonBeauty, в методе AddService, где нам приходит объект с типом Servce, однако метод вернет результат именно от того типа который пришел. А так же в классе стилиста в методе DisplayInfo

Что имеем далее - класс заказ, который будет просто содержать список выбраных для заказа услуг и время создания, а так же свойство которое показыает сумму заказа.

Клас салона красоты переделал
Теперь у нас 3 мастера( по одному на каждый вид услуг, об этом подробнее будет ниже)

Список предоставляемых услуг
И список заказов

А так же определено 2 метода, добавить услугу, который работает с разными типами. Т.е. нам приходит какая - либо услуга. Например маникюр, в метод он попадает конкретно под типом услуги. Далее мы смотри, каким же типом онялвяется
Видим, что он я вляется типом маникюра, поэтому записываем эту новую услугу к мастеру по маникуюру. Делаем полиморный вызов и возвращаем сообщение
======================
Задание именно второй лабы
Во второй лабороаторной нам необходимо сделать кастонмую коллекцию т.е. создать класс который поддерживает интерфейс коллекции (например ICollection как у нас).

В качестве класса - коллекции был выбран клас стилист(мастер).
Теперь у нас в салоне красоты по одному мастеру на каждый вид услуг. И каждый мастер содержит внутри себя список - предоставляемые коннкретно им услуги.

Перейдем в класс
В самом верху мы пишем такую штуку
Stylist<T> : ICollection<T> - обязуем реализовать весь функционал коллекции в нашем класс
where T : Service - ограничение обобщения, что сюда модет попадать только тип услуги
Буква Т - обобщенияю То есть ммы пишем так Мастер<Маникюр> - это значит что тпереь этот мастер может выполнять только маникюрные услуги, и храниьт их в себе

Далее поля и свойства
- имя
- Список услуг
- Свойство - зарплаты, считает сумму цен всех предоставляемых услуг и сколько раз их заказали 
- count кол
-is readonly - это тупо нам обязет реализовать ICollection
- ServiceType - тип предоставляемых усулг строкой
Даллее методы, но все эти методы обязыет нас рализовать интерффейс ICollection кроме ToString и Display Info, это наши метода, то как быедт все выглядит в консоли строкой

===
Тпереь про коваринатность.
В задании требуется показать работу с ковариантностью обобенных интерфейсов. Это у нас есть в Файле Program В самом низу
Ковариантность -  позволяет использовать более конкретный тип, чем заданный изначально

Что у нас поисходит. Мы создаем инетефейс ICovarianceInterface - как мы определяем что он коваринатен? Все просто, написано слово out перед буквой Т
У НАС УСТЬ ОДИН КОВАРИНТЫЙ МЕТОД. КОВАРИНТНЫЙ МЕТОД МОЖЕТ ТОЛЬКО ВОЗВАРЩАТЬ ТИП Т. КОВАРИАНТНЫЙ ИНТЕРФЕС НЕ МОЖЕТ РЕАЛИЗОВЫВАТЬ МЕТОД КОТОРЫЕ ПРИНИМАЮТ Т КАК ВХОДНОЙ ПАРАМЕТР

Вся демонстрая происходит в методе Cov Demo
Там у нас происходит слудующее. Мы объявляем объект от интерфейса с более обощенным видомю Но создаем с боллее конктрентым
То есть мы можем присвоить более общему типу ICovarianceInterface<Service> объект более конкретного типа HairstyleMaster или ICovarianceInterface<Hairstyle>.

======
UPD. по второй лабе. Добавил интерфейс IStylist. То есть, шаблон того как должен выгляить класс стилиста, реализаторы этого интерфейса
так же должны реализовывать инттерфес ICollection, так как в объявлении интерфеса в верху мы написали вот это
public interface IStylist<T> : ICollection<T> where T : Service
interface - значит что это инттерфес
IStylist - название нашего интерфейса
<T> - это значит что он обобщенный, то есть внутри будет происходить взаимодействие именно с типом T - то есть напринмер. Стилист только для педикюра
IStylist<T> : ICollection<T>  - значит что имплиментирует(реализует) интерфейс ICollection
where T : Service - ограничение обобщения(тип Т является классов Service(услуга) или его наследником)


А так же в классе спа салона мы измени то, как храним каждого стилиста
было -  private Stylist<Hairstyle> hairdresser
стало-  private IStylist<Hairstyle> hairdresser
(Стали хранить под интерфейсом)

Так же, после того как люди еще сдали верману лабу, я передал пример с ковариантностью
В папку collection я добавил еще один интерфейс - ICovarionceInterfacе, он поддерживает коваринатность
Далее я добавил в наш класс Stylist реализацию и этого ковариантного интерфейса. Это нам понадобится для демонстрации ковариантности

И в интерфесе определил метод - SomeCovarianceMethod - ковариантный метод(возращает объект с типом T)
Ну и естественно, этот метод реализован в классе стилиста
Он будет возращать нам из нашей коллекции(стилиста), услугу, находя её по названию.

Метод с демонстрацией ковариантности вынес на самый верх и добавил его вызов в программе
Постарарался и поисал там все в коментариях.
Тема с коваринтностью, довольно таки непонятная, так что если что пиши вопросы

====== 
Лаба 3
От нас требуется добавить функцию сортировки в нашу коллекцию и испольщовать делегаты Action и Func
Будет вполне достаточно использование либо Action либо Func

- проделаны следующие действия
В файле интерфеса стилиста IStylist добавили метод для сортировки, то есть теперь классы реализующие интерфейс IStylist
будут обязаны определить и этот метод
public void SortServices(Func<T, T, bool> orderFunc);
Что за входной параметр Func<T, T, bool> orderFunc - Это делегат.
Что это? Это переменная, которая внутри себя содержит метод, то есть вы метод сортировки мы передаем метод, который будет сравнивать элементы
Делаем мы это, чтобы можно было задавать сортировку по различным параметрам(по названию и поцене). То есть нам будут поступать разные метды сравнения
Будем делать пузырьковую сортивроку


Предварительно создадим сами методы сравнения элментов по необходимым нам параметрам.
Зайдем в файлик Service, там в классе Serivce мы создадим 3 статических метода (static). 
Статические методы - методы которые не привяываются к определнному объекту класса. То есть нам не нудно создавать объект услуги чтоб вызвать этот метод

Эти методы будут приниамть как входной параметр 2 объекта услуг. И возвращать true если первый больше второго и false если наоборот.
Происходит это с помощью фукции сравнения которая возращает число
 // CompareTo возвращает 1- сли первый больше второ
 // 0 - равны
 // -1 - второй больше первого

Теперь в файле SalonBeauty в самом низу класса SalonBeauty мы определили метод, который будет выбирать метод сравнения элементов,
в зависимости от того по каким параметрам мы хотим отсортировать наши коллекции. Создадим перечисление (enum) чуть ниже и обхявим 3 параметра
1. Название 2. Цена 3. Количетсво заказов.
Поступив на вхож мы смотрим какой параметр был передам и в зависимости от этого
записываем необходимы статичекий метод в делегат, а далее у всех 4х стилистов вызываем метод сортировки, передавая туда выбранный метод сравнения

Все, можем любоавть отсортированными данными.
