Опишу что есть

- Иерархия классов
1. Базовый абстракный класс - услуга
2. Его наследники - Маникюр, Спа процедура, Работа св волосами так называемая
В класс наследники добавил различные детали
- требуется ли мойка волос
- цвет маникюра
- Время на спа процендуру

Так же добавил пример инкапсуляции(это надо в первой лабе, но вдргу споросит)
- в файле SpaProcedure то как мы устанавливаем время - на строке 5 у нас есть поле, которое хранит значене, однако обращаемся
мы к нему через свойство на строке 9. Там в set мы скрываем проверку правильности передданного значения

В абстракный класс добавил абстракный меотд DisplayInfo - метод который должен быть переопределе в каждом классе - наследнике.
Он переводин объект услуг в подробную информацию в строковом виде. В развных классах свое отображение. Вызов этого метода считается полиморфным (это нужно было в первой лабе, но вдруг спросит) - 
в классе SalonBeauty, в методе AddService, где нам приходит объект с типом Servce, однако метод вернет результат именно от того типа который пришел. А так же в классе стилиста в методе DisplayInfo

Что имеем далее - класс заказ, который будет просто содержать список выбраных для заказа услуг и время создания, а так же свойство которое показыает сумму заказа.

Клас салона красоты переделал
Теперь у нас 3 мастера( по одному на каждый вид услуг, об этом подробнее будет ниже)

Список предоставляемых услуг
И список заказов

А так же определено 2 метода, добавить услугу, который работает с разными типами. Т.е. нам приходит какая - либо услуга. Например маникюр, в метод он попадает конкретно под типом услуги. Далее мы смотри, каким же типом онялвяется
Видим, что он я вляется типом маникюра, поэтому записываем эту новую услугу к мастеру по маникуюру. Делаем полиморный вызов и возвращаем сообщение
======================
Задание именно второй лабы
Во второй лабороаторной нам необходимо сделать кастонмую коллекцию т.е. создать класс который поддерживает интерфейс коллекции (например ICollection как у нас).

В качестве класса - коллекции был выбран клас стилист(мастер).
Теперь у нас в салоне красоты по одному мастеру на каждый вид услуг. И каждый мастер содержит внутри себя список - предоставляемые коннкретно им услуги.

Перейдем в класс
В самом верху мы пишем такую штуку
Stylist<T> : ICollection<T> - обязуем реализовать весь функционал коллекции в нашем класс
where T : Service - ограничение обобщения, что сюда модет попадать только тип услуги
Буква Т - обобщенияю То есть ммы пишем так Мастер<Маникюр> - это значит что тпереь этот мастер может выполнять только маникюрные услуги, и храниьт их в себе

Далее поля и свойства
- имя
- Список услуг
- Свойство - зарплаты, считает сумму цен всех предоставляемых услуг и сколько раз их заказали 
- count кол
-is readonly - это тупо нам обязет реализовать ICollection
- ServiceType - тип предоставляемых усулг строкой
Даллее методы, но все эти методы обязыет нас рализовать интерффейс ICollection кроме ToString и Display Info, это наши метода, то как быедт все выглядит в консоли строкой

===
Тпереь про коваринатность.
В задании требуется показать работу с ковариантностью обобенных интерфейсов. Это у нас есть в Файле Program В самом низу
Ковариантность -  позволяет использовать более конкретный тип, чем заданный изначально

Что у нас поисходит. Мы создаем инетефейс ICovarianceInterface - как мы определяем что он коваринатен? Все просто, написано слово out перед буквой Т
У НАС УСТЬ ОДИН КОВАРИНТЫЙ МЕТОД. КОВАРИНТНЫЙ МЕТОД МОЖЕТ ТОЛЬКО ВОЗВАРЩАТЬ ТИП Т. КОВАРИАНТНЫЙ ИНТЕРФЕС НЕ МОЖЕТ РЕАЛИЗОВЫВАТЬ МЕТОД КОТОРЫЕ ПРИНИМАЮТ Т КАК ВХОДНОЙ ПАРАМЕТР

Вся демонстрая происходит в методе Cov Demo
Там у нас происходит слудующее. Мы объявляем объект от интерфейса с более обощенным видомю Но создаем с боллее конктрентым
То есть мы можем присвоить более общему типу ICovarianceInterface<Service> объект более конкретного типа HairstyleMaster или ICovarianceInterface<Hairstyle>.